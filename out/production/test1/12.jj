/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. 12.jj */
/*@egen*//* adder.jj Adding up numbers */
//EBNF\u93c2\u56e8\u7876

//program -> declaration-list
//###declaration-list -> declaration-list declaration | declaration
//declaration-list -> declaration{ declaration}
//declaration -> var-declaration | fun-declaration
//var-declaration -> type-specifier ID; | type-specifier ID[NUM];
//type-specifier -> int | void
//fun-declaration -> type-specifier ID (params) | compound-stmt
//params -> param-list | void
//param-list -> param-list, param | param
//param -> type-specifier ID | type-specifier ID[ ]
//compound-stmt -> {local-declarations statement-list}
//###local-declarations -> local-declarations var-declaration | empty
//local-declarations -> empty{ var-declaration}
//###statement-list -> statement-list statement | empty
//statement-list -> empty{ statement}
//statement -> expression-stmt | compound-stmt | selection-stmt | iteration-stmt | return stmt
//expression-stmt -> expression; | ;

//ifelse\u6dc7\ue1bd\u657c\u6769\ufffd,\u7459\uff45\u5585\u6d5c\u5c7c\u7b9f\u93ac\ufffd
//selection-stmt -> matched-stmt | unmatched-stmt
//!!!compound-stmt
//matched-stmt -> if (expression) matched-stmt else matched-stmt | compound-stmt
//unmatched-stmt -> if (expression) selection-stmt | if (expression) matched-stmt else unmatched-stmt

//iteration-stmt -> while (expression) statement
//return-stmt -> return; | return expression;
//expression -> var=expression | simple-expression
//var -> ID| ID[expression]
//simple-experession -> additive-expression relop additive-expression | additive-expression
//relop -> <=|<|>|>=|==|!=
//###additive-expression -> additive-expression addop term | term
//additive-expression -> term{ addop term}
//addop -> +|-
//###term -> term mulop factor | factor
//term -> factor{  mulop factor}
//mulop -> *|/
//factor -> (expression) | var | call | NUM
//call -> ID(args)
//args -> arg-list | empty
//###arg-list -> arg-list, expression| expression
//arg-list -> expression{ , expression}

//javacc C:\Users\CJH\IdeaProjects\MyCompiler\src\com\compiler\MyCompiler.jj

options {
    STATIC = false ;
                 
                   
}

PARSER_BEGIN(MyCompiler)
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;import java.util.*;
    class MyCompiler/*@bgen(jjtree)*/implements MyCompilerTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTMyCompilerState jjtree = new JJTMyCompilerState();

/*@egen*/

        private ErrorList errorList = new ErrorList();
        private SymbolTable symbolTable = new SymbolTable();
        private CodeGen codeGen = new CodeGen(false);

        public static void main( String[] args ) throws TokenMgrError, FileNotFoundException, ParseException {

            String path = "C:\\Users\\CJH\\IdeaProjects\\test1\\test.txt";
            FileInputStream fileInputStream = new FileInputStream(new File(path));
            MyCompiler parser = new MyCompiler(fileInputStream);
            parser.program();
            SimpleNode node = (SimpleNode)parser.jjtree.rootNode();
            node.dump("");
            parser.errorList.printError();
        List<String> qt = parser.codeGen.getQt();
        for (String q : qt) {
            System.out.println(q);
        }
        }
    }
PARSER_END(MyCompiler)

//\u74ba\u5ba0\u7e43
SKIP : {
    //\u7ecc\u70d8\u7278\u93b9\u3223\ue511\u9352\u60f0\u3003\u7ed7\ufffd
    " "
    | "\n"
    | "\r"
    | "\t"
    //\u74ba\u5ba0\u7e43\u9357\u66e1\ue511\u5a09\u3129\u5674
    | <"//"(~["\n", "\r"])*("\n"
    | "\r"
    | "\r\n")>
    //\u74ba\u5ba0\u7e43\u6fb6\u6c33\ue511\u5a09\u3129\u5674
    | <"/*"(~["*"])*"*"(~["/"](~["*"])*"*")*"/">
}

//\u7039\u6c2b\u7b9f\u934f\u62bd\u656d\u701b\ufffd
TOKEN:
{
    < IF : "if" >

    | < ELSE : "else" >

    | < WHILE : "while" >

    | < INT : "int" >

    | < RETURN : "return" >

    | < VOID : "void" >

    | < OUTPUT : "output" >

    | < INPUT : "input" >
}

//\u7039\u6c2b\u7b9f\u93cd\u56ea\u7611\u7ed7\ufffd
TOKEN : {
    < #letter : ["a" - "z" , "A" - "Z"] >

    | < ID : (<letter>)+ >
}

//\u7039\u6c2b\u7b9f\u93c1\u5b58\u669f
TOKEN : {
    < #digit : ["0" - "9"] >

    | < NUM : (<digit>)+ >
}

//\u7039\u6c2b\u7b9f\u7ed7\ufe40\u5f7f
TOKEN : {
    < SEMICOLON:";" >

    | < EQUAL : "==" >

    | < NOTEQUAL : "!=" >

    | < ASSIGN : "=" >

    | < PLUS : "+" >

    | < MINUS : "-" >

    | < TIMES : "*" >

    | < DIVIDE : "/" >

    | < COMMA : "," >

    | < LEFTPARENTHESES: "(" >

    | < RIGHTPARENTHESES : ")" >

    | < LEFTBRACKET : "[" >

    | < RIGHTBRACKET : "]" >

    | < ALLBRACKET : (<letter>)+"[]" >

    | < ARRAYELEMENT : <ID>"[" >

    | < LEFTBRACES : "{" >

    | < RIGHTBRACES : "}" >

    | < LT : "<" >

    | < GT : ">" >

    | < LTE : "<=" >

    | < GTE : ">=" >


}

//program -> declaration-list
void program() :
{/*@bgen(jjtree) program */
 ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token id;}
{/*@bgen(jjtree) program */
    try {
/*@egen*/
    {
        HashMap<String, VarInfo> map = new HashMap<String, VarInfo>();
        symbolTable.getVarList().add(map);
        codeGen.emitRM(codeGen.OP_LD,codeGen.REG_MP,0,codeGen.REG_AC,"load maxaddress from location 0");
        codeGen.emitRM(codeGen.OP_ST,codeGen.REG_AC,0,codeGen.REG_AC,"clear location 0");
        codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_LP,0,codeGen.REG_GP,"init lp");
        codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_SP,0,codeGen.REG_GP,"init sp");
    }
    declarationList()
    id = <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    if (!"main".equals(symbolTable.getLatestDeclarationFun().getName())) {
        errorList.addLastNotMain(id);
    }
     //leave a  block,remove a new hashmap
    symbolTable.getVarList().remove(symbolTable.getVarList().size() - 1);
    codeGen.emitRO(codeGen.OP_HALT,0,0,0,"");
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//declaration-list -> declaration{ declaration}
void declarationList() :
{/*@bgen(jjtree) declarationList */
  ASTdeclarationList jjtn000 = new ASTdeclarationList(JJTDECLARATIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) declarationList */
    try {
/*@egen*/
    declaration()
    (
        declaration()
    )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
//declaration -> var-declaration | fun-declaration
void declaration() :
{/*@bgen(jjtree) declaration */
  ASTdeclaration jjtn000 = new ASTdeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) declaration */
   try {
/*@egen*/
   LOOKAHEAD(2147483647) varDeclaration() |
   funDeclaration()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/

}


//var-declaration -> type-specifier ID; | type-specifier ID[NUM];
/**
* var-declaration -> type-specifier ID; | type-specifier ID[NUM];
* \u9365\u72b1\u8d1f\u9359\ue047\u5158\u7039\u6c2b\u7b9fint\u9359\u6a40\u567a\u935c\u5c7e\u669f\u7f01\u52f6\u7d1d\u93c1\u546c\u6168\u93c0\ufffd
* var-declaration -> int ID; | int ID[NUM];
*/
void varDeclaration() :
{/*@bgen(jjtree) varDeclaration */
  ASTvarDeclaration jjtn000 = new ASTvarDeclaration(JJTVARDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  Token id;
  VarInfo var;
  Token size;
}
{/*@bgen(jjtree) varDeclaration */
    try {
/*@egen*/
    LOOKAHEAD(2147483647) <INT> id = <ID>  <SEMICOLON>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    var = new VarInfo("int", id);
    var.setSize(1);
    if (!symbolTable.addVar(var))
    {
        errorList.addVarHaveDeclared(id);
    } else {
        codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_SP,1,codeGen.REG_SP,"var local ins sp") ;
        if (symbolTable.isGlobalVar(id.image)) {
            codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_LP,1,codeGen.REG_LP,"var global ins sp") ;
        }
    }
    }
    | <INT> id = <ARRAYELEMENT> size = <NUM> <RIGHTBRACKET> <SEMICOLON>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        id.image = id.image.replace("[", "");
        var = new VarInfo("int[]", id);
        var.setSize(Integer.parseInt(size.image));
        if (!symbolTable.addVar(var))
        {
            errorList.addVarHaveDeclared(id);
        } else {
            codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_SP,Integer.parseInt(size.image),codeGen.REG_SP,"var[] local ins sp") ;
             if (symbolTable.isGlobalVar(id.image)) {
                 codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_LP,Integer.parseInt(size.image),codeGen.REG_LP,"var global ins sp") ;
             }
        }
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//fun-declaration -> type-specifier ID (params) | compound-stmt
void funDeclaration() :
{/*@bgen(jjtree) funDeclaration */
    ASTfunDeclaration jjtn000 = new ASTfunDeclaration(JJTFUNDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token id;
    Token returnType;
    FunInfo fun;
    List<VarInfo> par;
    int callFunLoc = 0;
    int jumpLoc = 0;
    int currentLoc = 0;
}
{/*@bgen(jjtree) funDeclaration */
    try {
/*@egen*/
    returnType = <INT> id = <ID>  <LEFTPARENTHESES> par = params() <RIGHTPARENTHESES>
    {
        if (!"main".equals(id.image)){
            jumpLoc = codeGen.emitSkip(1);
        }
        //Define the function header, pay attention to record the return value
        fun = new FunInfo(returnType.image, id, par);
        callFunLoc = codeGen.emitSkip(0);
        fun.setLoc(callFunLoc);
        if (!symbolTable.addFun(fun))
        {
            errorList.addFunHaveDeclared(id);
        } else {

            List<VarInfo> tempFunPar = symbolTable.getTempFunPar();
            tempFunPar.clear();
            //add the symbol to it inorder to init the fun symbol
            tempFunPar.addAll(par);
        }
    }
    compoundStmt()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {

        if (!"main".equals(id.image)){
            codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_PC,0,codeGen.REG_FP,"jump  back to caller");
            currentLoc = codeGen.emitSkip(0);
            codeGen.emitBackup(jumpLoc);
            codeGen.emitRM_Abs(codeGen.OP_LDA,codeGen.REG_PC,currentLoc,"jmp to fun end");
            codeGen.emitRestore();
        }
     }

    | returnType = <VOID> id = <ID>  <LEFTPARENTHESES> par = params() <RIGHTPARENTHESES>
    //\u7039\u6c2b\u7b9f\u9351\u82a5\u669f\u6fb6\ufffd,\u5a09\u3126\u5270\u7481\u677f\u7d8d\u6769\u65bf\u6d16\u934a\ufffd
    {
        if (!"main".equals(id.image)){
            jumpLoc = codeGen.emitSkip(1);
        }
        //Define the function header, pay attention to record the return value
        fun = new FunInfo(returnType.image, id, par);
        callFunLoc = codeGen.emitSkip(0);
        fun.setLoc(callFunLoc);
        if (!symbolTable.addFun(fun))
        {
            errorList.addFunHaveDeclared(id);
        } else {
             List<VarInfo> tempFunPar = symbolTable.getTempFunPar();
             tempFunPar.clear();
             //add the symbol to it inorder to init the fun symbol
             tempFunPar.addAll(par);
        }
    }
    compoundStmt()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        if (!"main".equals(id.image)){
            codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_PC,0,codeGen.REG_FP,"jump  back to caller") ;
            currentLoc = codeGen.emitSkip(0);
            codeGen.emitBackup(jumpLoc);
            codeGen.emitRM_Abs(codeGen.OP_LDA,codeGen.REG_PC,currentLoc,"jmp to fun end");
            codeGen.emitRestore();
        }
     }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//params -> param-list | void
List<VarInfo> params() :
{/*@bgen(jjtree) params */
 ASTparams jjtn000 = new ASTparams(JJTPARAMS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 List<VarInfo> par;
 }
{/*@bgen(jjtree) params */
    try {
/*@egen*/
    LOOKAHEAD(2147483647) par = paramList()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return par;
    }
    | <VOID>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return Collections.emptyList();}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//param-list -> param{ , param}
List<VarInfo> paramList() :
{/*@bgen(jjtree) paramList */
 ASTparamList jjtn000 = new ASTparamList(JJTPARAMLIST);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 List<VarInfo> par;
 VarInfo para;
 }
{/*@bgen(jjtree) paramList */
    try {
/*@egen*/
    para = param()
    {
        par = new ArrayList<VarInfo>();
        par.add(para);
    }
    (
        <COMMA>
        para = param()
        {
            par.add(para);
        }
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return par;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

/**
* param -> type-specifier ID | type-specifier ID[]
* \u93c0\u5f52\ufffd\u72b3\u6783\u5a09\ufffd
* param -> int ID | int ID[]
*/
VarInfo param() :
{/*@bgen(jjtree) param */
 ASTparam jjtn000 = new ASTparam(JJTPARAM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token id;}
{/*@bgen(jjtree) param */
    try {
/*@egen*/
    LOOKAHEAD(2147483647) <INT> id = <ID>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return new VarInfo("int", id.image);
    }
    | <INT> id = <ARRAYELEMENT> <RIGHTBRACKET>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        id.image = id.image.replace("]","");
        return new VarInfo("int[]", id.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//compound-stmt -> {local-declarations statement-list}
void compoundStmt() :
{/*@bgen(jjtree) compoundStmt */
 ASTcompoundStmt jjtn000 = new ASTcompoundStmt(JJTCOMPOUNDSTMT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 int paraSize = 0;
 int sp = 0;
}
{/*@bgen(jjtree) compoundStmt */
    try {
/*@egen*/
    <LEFTBRACES>
    {
    //enter a new block,create a new hashmap
    HashMap<String, VarInfo> map = new HashMap<String, VarInfo>();
    symbolTable.getVarList().add(map);
    for (VarInfo e :symbolTable.getTempFunPar()) {
        if ("int".equals(e.getType())) {
            e.setSize(1);
        } else{
            e.setSize(50);
        }
        symbolTable.addVar(e);
        paraSize = e.getSize();
    }
    codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_SP,paraSize,codeGen.REG_SP,"ins sp") ;
    symbolTable.getTempFunPar().clear();
    }
    localDeclarations()
    statementList()
    {
      //leave a  block,remove a new hashmap
      sp = symbolTable.reduceLocalSize();
      codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_SP,-sp,codeGen.REG_SP,"des sp") ;
      symbolTable.getVarList().remove(symbolTable.getVarList().size() - 1);
    }
    <RIGHTBRACES>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//local-declarations -> empty{ var-declaration}
void localDeclarations() :
{/*@bgen(jjtree) localDeclarations */
  ASTlocalDeclarations jjtn000 = new ASTlocalDeclarations(JJTLOCALDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) localDeclarations */
    try {
/*@egen*/
    (
        varDeclaration()
    )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//statement-list -> empty{ statement}
void statementList() :
{/*@bgen(jjtree) statementList */
  ASTstatementList jjtn000 = new ASTstatementList(JJTSTATEMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statementList */
    try {
/*@egen*/
    (
        statement()
    )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//statement -> expression-stmt | compound-stmt | selection-stmt | iteration-stmt | return stmt
void statement() :
{/*@bgen(jjtree) statement */
  ASTstatement jjtn000 = new ASTstatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement */
    try {
/*@egen*/
    LOOKAHEAD(2147483647) expressionStmt()|
    LOOKAHEAD(2147483647) compoundStmt()|
    LOOKAHEAD(2147483647) selectionStmt()|
    iterationStmt()|
    returnStmt()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


//expression-stmt -> expression; | ;
void expressionStmt() :
{/*@bgen(jjtree) expressionStmt */
  ASTexpressionStmt jjtn000 = new ASTexpressionStmt(JJTEXPRESSIONSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expressionStmt */
    try {
/*@egen*/
    expression() <SEMICOLON>
    | <SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//selection-stmt -> matched-stmt | unmatched-stmt
void selectionStmt() :
{/*@bgen(jjtree) selectionStmt */
  ASTselectionStmt jjtn000 = new ASTselectionStmt(JJTSELECTIONSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  int savedLoc1 = 0;
  int savedLoc2 = 0;
  int currentLoc = 0;
  Token exp;
 }
{/*@bgen(jjtree) selectionStmt */
      try {
/*@egen*/
      LOOKAHEAD(2147483647)
       <IF> <LEFTPARENTHESES> exp = expression()
      {
              if (!"int".equals(exp.type)) {
                  errorList.addVarNotDeclared(exp);
              } else {
                  savedLoc1 = codeGen.emitSkip(1);
              }
       }
       <RIGHTPARENTHESES> statement()
       {
            savedLoc2 = codeGen.emitSkip(1);
            currentLoc = codeGen.emitSkip(0);
            codeGen.emitBackup(savedLoc1);
            codeGen.emitRM_Abs(codeGen.OP_JEQ,codeGen.REG_AC,currentLoc,"if: jmp to else");
            codeGen.emitRestore() ;
        }
       <ELSE> statement()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
       }
/*@egen*/
       {
           currentLoc = codeGen.emitSkip(0);
           codeGen.emitBackup(savedLoc2);
           codeGen.emitRM_Abs(codeGen.OP_LDA,codeGen.REG_PC,currentLoc,"if jmp to end");
           codeGen.emitRestore();
       }
       |
      <IF> <LEFTPARENTHESES> exp = expression()
      {
          if (!"int".equals(exp.type)) {
              errorList.addExpSubscript(exp);
          } else {
              savedLoc1 = codeGen.emitSkip(1);
          }
       }
      <RIGHTPARENTHESES> statement()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/
      {
            currentLoc = codeGen.emitSkip(0);
            codeGen.emitBackup(savedLoc1);
            codeGen.emitRM_Abs(codeGen.OP_JEQ,codeGen.REG_AC,currentLoc,"if: jmp to end");
            codeGen.emitRestore() ;
      }/*@bgen(jjtree)*/
      } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          throw (RuntimeException)jjte000;
        }
        if (jjte000 instanceof ParseException) {
          throw (ParseException)jjte000;
        }
        throw (Error)jjte000;
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
}

//iteration-stmt -> while (expression) statement
void iterationStmt() :
{/*@bgen(jjtree) iterationStmt */
    ASTiterationStmt jjtn000 = new ASTiterationStmt(JJTITERATIONSTMT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    int savedLoc1 = 0;
    int savedLoc2 = 0;
    int currentLoc = 0;
    Token exp;
}
{/*@bgen(jjtree) iterationStmt */
    try {
/*@egen*/
    <WHILE> <LEFTPARENTHESES>
    {
        savedLoc1 = codeGen.emitSkip(0);
    }
    exp = expression()
    {
        if (!"int".equals(exp.type)) {
            errorList.addLeftAndRightNotInt(exp);
        } else {
            savedLoc2 = codeGen.emitSkip(1);
        }
     }
    <RIGHTPARENTHESES> statement()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        codeGen.emitRM_Abs(codeGen.OP_LDA,codeGen.REG_PC,savedLoc1,"while unconditional jmp") ;

        currentLoc = codeGen.emitSkip(0);
        codeGen.emitBackup(savedLoc2);
        codeGen.emitRM_Abs(codeGen.OP_JEQ,codeGen.REG_AC,currentLoc,"while out of body");
        codeGen.emitRestore();
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//return-stmt -> return; | return expression;
void returnStmt() :
{/*@bgen(jjtree) returnStmt */
    ASTreturnStmt jjtn000 = new ASTreturnStmt(JJTRETURNSTMT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token retExp;
}
{/*@bgen(jjtree) returnStmt */
    try {
/*@egen*/
    LOOKAHEAD(2147483647) retExp = <RETURN> <SEMICOLON>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        //\u59ab\ufffd\u93cc\u30e8\u7e51\u9365\u70b2\ufffd\u517c\u69f8\u935a\ufe40\u62f0\u9351\u82a5\u669f\u6fb6\u6751\u757e\u6d94\u590c\u6b91\u6d93\ufffd\u9477\ufffd
        if ("void".equals(symbolTable.getLatestDeclarationFun().getReturnType())) {
                String errorInfo = retExp.beginLine + ":" + retExp.beginColumn +
                " The type of the return value is inconsistent with the function definition";
                errorList.addError(errorInfo);
        }
    }
    | <RETURN> retExp = expression() <SEMICOLON>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        //\u59ab\ufffd\u93cc\u30e8\u7e51\u9365\u70b2\ufffd\u517c\u69f8\u935a\ufe40\u62f0\u9351\u82a5\u669f\u6fb6\u6751\u757e\u6d94\u590c\u6b91\u6d93\ufffd\u9477\ufffd
        if (!retExp.type.equals(symbolTable.getLatestDeclarationFun().getReturnType())) {
                String errorInfo = retExp.beginLine + ":" + retExp.beginColumn +
                " The type of the return value is inconsistent with the function definition";
                errorList.addError(errorInfo);
        }
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//expression -> var=expression | simple-expression
Token expression() :
{/*@bgen(jjtree) expression */
  ASTexpression jjtn000 = new ASTexpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token left;
  Token right;
  int loc;
  String varName;
}
{/*@bgen(jjtree) expression */
    try {
/*@egen*/
    LOOKAHEAD(2147483647) left = var()
    {
        varName = left.image;
        codeGen.emitRM(codeGen.OP_ST,codeGen.REG_AC1,codeGen.tmpOffset--,codeGen.REG_MP,"op: push index");
    }
    <ASSIGN> right = expression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    //\u59ab\ufffd\u93cc\u30e5\u5f78\u6748\u89c4\u69f8\u935a\ufe3f\u8d1fint\u7eeb\u8bf2\u7037\u9428\u52ee\u3003\u6748\u60e7\u7d21
    if (!"int".equals(right.type)) {
        errorList.addLeftIsNotInt(right);
    } else {
        if (varName.contains("[")) {
            varName = varName.substring(0, varName.indexOf("["));
        }
        codeGen.emitRM(codeGen.OP_LD,codeGen.REG_AC1,++codeGen.tmpOffset,codeGen.REG_MP,"op: load index");
        if (symbolTable.isGlobalVar(varName)) {
            codeGen.emitRM(codeGen.OP_STS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_GP,"assign: global store value");
        } else {
            codeGen.emitRM(codeGen.OP_STS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_LP,"assign: local store value");
        }
    }
    left.type = "void";
    //the type of assgin is void
    return left;
}
    | left = simpleExperession()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return left;
     }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//var -> ID| ID[expression]
Token var() :
{/*@bgen(jjtree) var */
    ASTvar jjtn000 = new ASTvar(JJTVAR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token id;
    Token exp;
    VarInfo var;
    int loc;
}
{/*@bgen(jjtree) var */
    try {
/*@egen*/
    id = <ID>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        var = symbolTable.checkUndefined(id.image);
        if (var == null) {
            errorList.addVarNotDeclared(id);
        } else if (!"int".equals(var.getType())) {
            errorList.addVarNotDeclared(id);
        } else {
            loc = symbolTable.getVarLocByVarName(id.image);
            codeGen.emitRM(codeGen.OP_LDC,codeGen.REG_AC1,loc,0,"load const");
            if (var.getGlobal()) {
                codeGen.emitRM(codeGen.OP_LDS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_GP, "load global id value");
            } else {
                codeGen.emitRM(codeGen.OP_LDS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_LP, "load local id value");
            }
        }
        return id;
    }
    | id = <ARRAYELEMENT> exp = expression() <RIGHTBRACKET>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        id.image = id.image.replace("[", "");
        var = symbolTable.checkUndefined(id.image);
        if (var == null)
        {
            errorList.addVarNotDeclared(id);
        } else if (!"int[]".equals(var.getType())) {
            errorList.addVarNotDeclared(id);
        }
        else
        {
            //Checks if the right side is an expression of type int
            if (!"int".equals(exp.type)) {
              errorList.addArraySubscript(exp);
            } else{
                //Get the starting index of the array
                loc = symbolTable.getVarLocByVarName(id.image);
                codeGen.emitRM(codeGen.OP_LDC,codeGen.REG_AC1,loc,0,"load const");
                //Get the corresponding index of the element
                codeGen.emitRO(codeGen.OP_ADD,codeGen.REG_AC1,codeGen.REG_AC1,codeGen.REG_AC,"op +");
                if (var.getGlobal()) {
                    codeGen.emitRM(codeGen.OP_LDS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_GP, "load global id value");
                } else {
                    codeGen.emitRM(codeGen.OP_LDS, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_LP, "load local id value");
                }
            }
        }
        id.image = id.image + "[" + exp.image + "]";
        id.type = "int";
        return id;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


//simple-experession -> additive-expression (relop additive-expression)?
Token simpleExperession() :
{/*@bgen(jjtree) simpleExperession */
  ASTsimpleExperession jjtn000 = new ASTsimpleExperession(JJTSIMPLEEXPERESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token ret;
  Token temp;
 Token re;
 }
{/*@bgen(jjtree) simpleExperession */
    try {
/*@egen*/
    ret = additiveExpression()
    [
        re = relop()
        {
            codeGen.emitRO(codeGen.OP_ST, codeGen.REG_AC, codeGen.tmpOffset--, codeGen.REG_MP, "op: push left");
            /* gen code for ac = right operand */
        }
        temp = additiveExpression()
        {
            //\u9359\ue045\u6e41int\u9473\u82a5\u762e\u6748\u51bf\u7d1d\u8930\u64b2\u88b1\u6d93\ue045\u6e41\u6d93\ufffd\u6d93\ue043\u7b09\u93c4\u75e0nt\u7eeb\u8bf2\u7037\u93c3\ufffd
            if (!"int".equals(ret.type) || !"int".equals(temp.type)) {
                errorList.addLeftAndRightNotInt(ret);
            } else {
                codeGen.emitRO(codeGen.OP_LD, codeGen.REG_AC1, ++codeGen.tmpOffset, codeGen.REG_MP, "op: load left");
                codeGen.emitRO(codeGen.OP_SUB, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_AC, "sub before relop");
                switch (re.image) {
                    case "<=": {
                        codeGen.emitRM(codeGen.OP_JLE,codeGen.REG_AC,2,codeGen.REG_PC, "op <=");
                        break;
                    }
                    case "<": {
                        codeGen.emitRM(codeGen.OP_JLT, codeGen.REG_AC,2,codeGen.REG_PC, "op <");
                        break;
                    }
                    case ">": {
                        codeGen.emitRM(codeGen.OP_JGT, codeGen.REG_AC,2,codeGen.REG_PC, "op >");
                        break;
                    }
                    case ">=": {
                        codeGen.emitRM(codeGen.OP_JGE, codeGen.REG_AC,2,codeGen.REG_PC, "op >=");
                        break;
                    }
                    case "==": {
                        codeGen.emitRM(codeGen.OP_JEQ, codeGen.REG_AC,2,codeGen.REG_PC, "op ==");
                        break;
                    }
                    case "!=": {
                        codeGen.emitRM(codeGen.OP_JNE, codeGen.REG_AC,2,codeGen.REG_PC, "op !=");
                        break;
                    }
                    default:
                }
                codeGen.emitRM(codeGen.OP_LDC,codeGen.REG_AC,0,codeGen.REG_AC, "false case");
                codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_PC,1,codeGen.REG_PC, "unconditional jmp");
                codeGen.emitRM(codeGen.OP_LDC,codeGen.REG_AC,1,codeGen.REG_AC, "true case");
            }
            ret.type = "int";
        }
    ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return ret;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//relop -> <=|<|>|>=|==|!=
Token relop() :
{/*@bgen(jjtree) relop */
 ASTrelop jjtn000 = new ASTrelop(JJTRELOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token id;}
{/*@bgen(jjtree) relop */
    try {
/*@egen*/
    id = <LTE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return id;}
    | id = <LT>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {return id;}
    | id = <GT>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {return id;}
    | id = <GTE>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {return id;}
    | id = <EQUAL>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {return id;}
    | id = <NOTEQUAL>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ {return id;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

//additive-expression -> term{ addop term}
Token additiveExpression() :
{/*@bgen(jjtree) additiveExpression */
  ASTadditiveExpression jjtn000 = new ASTadditiveExpression(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token op;
  Token ret;
  Token temp;
}
{/*@bgen(jjtree) additiveExpression */
    try {
/*@egen*/
    ret = term()
    (
        op = addop()
        {
            codeGen.emitRO(codeGen.OP_ST, codeGen.REG_AC, codeGen.tmpOffset--, codeGen.REG_MP, "op: push left");
            /* gen code for ac = right operand */
        }
        temp = term()
        {
            //when one of them are not int
            if (!"int".equals(ret.type) || !"int".equals(temp.type)) {
                errorList.addLeftAndRightNotInt(ret);
            } else {
                codeGen.emitRO(codeGen.OP_LD, codeGen.REG_AC1, ++codeGen.tmpOffset, codeGen.REG_MP, "op: load left");
                if ("+".equals(op.image)) {
                    codeGen.emitRO(codeGen.OP_ADD, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_AC,"op +");
                } else {
                    codeGen.emitRO(codeGen.OP_SUB, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_AC,"op -");
                }
            }
            ret.type = "int";
    }
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return ret;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


//term -> factor{  mulop factor}
Token term() :
{/*@bgen(jjtree) term */
 ASTterm jjtn000 = new ASTterm(JJTTERM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Token op;
  Token ret;
  Token temp;
 }
{/*@bgen(jjtree) term */
    try {
/*@egen*/
    ret = factor()
    (
        op = mulop()
        {
            codeGen.emitRO(codeGen.OP_ST, codeGen.REG_AC, codeGen.tmpOffset--, codeGen.REG_MP, "op: push left");
            /* gen code for ac = right operand */
        }
        temp = factor()
        {
            //judge whereter the left and right are both int
            if (!"int".equals(ret.type) || !"int".equals(temp.type)) {
                errorList.addLeftAndRightNotInt(ret);
            } else {
                codeGen.emitRO(codeGen.OP_LD, codeGen.REG_AC1, ++codeGen.tmpOffset, codeGen.REG_MP, "op: load left");
                if ("*".equals(op.image)) {
                    codeGen.emitRO(codeGen.OP_MUL, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_AC,"op *");
                } else {
                    codeGen.emitRO(codeGen.OP_DIV, codeGen.REG_AC, codeGen.REG_AC1, codeGen.REG_AC,"op /");
                }
            }
            ret.type = "int";
        }
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return ret;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
//addop -> +|-
Token addop()  :
{/*@bgen(jjtree) addop */
 ASTaddop jjtn000 = new ASTaddop(JJTADDOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token id;}
{/*@bgen(jjtree) addop */
    try {
/*@egen*/
    id = <PLUS>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {return id;}
    | id = <MINUS>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {return id;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//mulop -> *|/
Token mulop()  :
{/*@bgen(jjtree) mulop */
 ASTmulop jjtn000 = new ASTmulop(JJTMULOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token id;}
{/*@bgen(jjtree) mulop */
    try {
/*@egen*/
    id = <TIMES>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {return id;}
    | id = <DIVIDE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return id;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//factor -> (expression) | var | call | NUM
Token factor() :
{/*@bgen(jjtree) factor */
 ASTfactor jjtn000 = new ASTfactor(JJTFACTOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Token t;
 }
{/*@bgen(jjtree) factor */
    try {
/*@egen*/

    <LEFTPARENTHESES> t = expression() <RIGHTPARENTHESES>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return t;
    }
    |  LOOKAHEAD(2147483647) t = call()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return t;
    }
    | t = var()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        t.type = "int";
        return t;
    }
    | t = <NUM>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        codeGen.emitRM(codeGen.OP_LDC, codeGen.REG_AC, Integer.parseInt(t.image), 0, "load const");
        t.type = "int";
        return t;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//call -> ID(args)
Token call() :
{/*@bgen(jjtree) call */
 ASTcall jjtn000 = new ASTcall(JJTCALL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Token id;
 List<String> arList;
 int jumpLoc;
 }
{/*@bgen(jjtree) call */
    try {
/*@egen*/
    id = <ID>
    {
        FunInfo fun = symbolTable.getFunInfoByName(id.image);
        if (fun == null)
        {
          errorList.addFunNotDeclared(id);
        } else {
            //st lp to prepare arg
            codeGen.emitRM(codeGen.OP_ST,codeGen.REG_SP,codeGen.tmpOffset--,codeGen.REG_MP,"push sp");
            codeGen.emitRM(codeGen.OP_ST,codeGen.REG_LP,codeGen.tmpOffset--,codeGen.REG_MP,"push lp");
            codeGen.emitRM(codeGen.OP_ST,codeGen.REG_FP,codeGen.tmpOffset--,codeGen.REG_MP,"push fp");
        }
    }
    <LEFTPARENTHESES> arList = args() <RIGHTPARENTHESES>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        //\u93cc\u30e6\u58d8\u9351\u82a5\u669f\u93c8\u590b\u68e4\u7039\u6c2b\u7b9f
        if (fun == null)
        {
          errorList.addFunNotDeclared(id);
        }
        else
        {
          //\u93cc\u30e6\u58d8\u9359\u509b\u669f\u9352\u6944\u3003
          List<VarInfo> params = fun.getParams();
          id.type = fun.getReturnType();
          //\u8930\u3220\u5f2c\u93c1\u4f34\u567a\u7eeb\u8bf2\u7037\u59ab\ufffd\u93cc\ufffd
          if (params.size() != arList.size()) {
              errorList.addFunArgSizeError(id);
          } else {
              boolean flag = true;
              for(int i = 0; i < params.size(); i++) {
                if (!params.get(i).getType().equals(arList.get(i))) {
                    flag = false;
                    break;
                }
              }
              if (!flag) {
                  errorList.addFunArgTypeError(id);
              } else {
                  //true case
                  codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_LP,0,codeGen.REG_SP,"get new Lp");
                  codeGen.emitRM(codeGen.OP_LDA,codeGen.REG_FP,1,codeGen.REG_PC,"get new fp");
                  jumpLoc = fun.getLoc();
                  codeGen.emitRM_Abs(codeGen.OP_LDA,codeGen.REG_PC,jumpLoc,"jump to fun");
                  codeGen.emitRM(codeGen.OP_LD,codeGen.REG_FP,++codeGen.tmpOffset,codeGen.REG_MP,"op: load fp");
                  codeGen.emitRM(codeGen.OP_LD,codeGen.REG_LP,++codeGen.tmpOffset,codeGen.REG_MP,"op: load lp");
                  codeGen.emitRM(codeGen.OP_LD,codeGen.REG_SP,++codeGen.tmpOffset,codeGen.REG_MP,"op: load sp");
              }
          }
          id.type = fun.getReturnType();
        }
        return id;
    }
    | <OUTPUT> <LEFTPARENTHESES> id = expression() <RIGHTPARENTHESES>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        if (!"int".equals(id.type)) {
            errorList.addFunArgTypeError(id);
        }
        codeGen.emitRO(codeGen.OP_OUT, codeGen.REG_AC, 0,0,"write ac");
        return new Token("void");
    }
    | id = <INPUT> <LEFTPARENTHESES> <RIGHTPARENTHESES>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        codeGen.emitRO(codeGen.OP_IN, codeGen.REG_AC, 0,0,"read integer value");
        id.type = "int";
        return id;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//args -> arg-list | empty
List<String> args() :
{/*@bgen(jjtree) args */
    ASTargs jjtn000 = new ASTargs(JJTARGS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    List<String> args;
 }
{/*@bgen(jjtree) args */
    try {
/*@egen*/
    [
        args = argList()
        {
            return args;
        }
    ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
//        args = new ArrayList<String>();
//        args.add("void");
        return Collections.emptyList();
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//arg-list -> expression{ , expression}
List<String> argList() :
{/*@bgen(jjtree) argList */
 ASTargList jjtn000 = new ASTargList(JJTARGLIST);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;
List<String> args;
int i = 0;
}
{/*@bgen(jjtree) argList */
    try {
/*@egen*/
    t = expression()
    {
        args = new ArrayList<String>();
        args.add(t.type);
        if ("int".equals(t.type)) {
            codeGen.emitRM(codeGen.OP_ST,codeGen.REG_AC,i++,codeGen.REG_SP,"prepare arg");
        } else {
            codeGen.emitRM(codeGen.OP_ST,codeGen.REG_AC,i,codeGen.REG_SP,"prepare arg");
            i += 50;
        }
    }
    (
        <COMMA>
        t = expression()
        {
            if ("int".equals(t.type)) {
                codeGen.emitRM(codeGen.OP_ST,codeGen.REG_AC,i++,codeGen.REG_SP,"prepare arg");
            } else {
                codeGen.emitRM(codeGen.OP_ST,codeGen.REG_AC,i,codeGen.REG_SP,"prepare arg");
                i += 50;
            }
        }
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return args;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}